/*
 * Copyright The OpenTelemetry Authors
 * SPDX-License-Identifier: Apache-2.0
 */

package io.opentelemetry.javaagent.tooling.bytebuddy.matcher;

import static io.opentelemetry.javaagent.extension.matcher.AgentElementMatchers.implementsInterface;
import static net.bytebuddy.matcher.ElementMatchers.named;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import io.opentelemetry.javaagent.tooling.bytebuddy.matcher.testclasses.A;
import io.opentelemetry.javaagent.tooling.bytebuddy.matcher.testclasses.B;
import io.opentelemetry.javaagent.tooling.bytebuddy.matcher.testclasses.E;
import io.opentelemetry.javaagent.tooling.bytebuddy.matcher.testclasses.F;
import io.opentelemetry.javaagent.tooling.bytebuddy.matcher.testclasses.G;
import io.opentelemetry.javaagent.tooling.muzzle.AgentTooling;
import java.util.stream.Stream;
import net.bytebuddy.description.NamedElement;
import net.bytebuddy.description.type.TypeDescription;
import net.bytebuddy.description.type.TypeList;
import net.bytebuddy.matcher.ElementMatcher;
import net.bytebuddy.pool.TypePool;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

class ImplementsInterfaceMatcherTest {

  private static TypePool typePool;

  @BeforeAll
  static void setUp() {
    typePool =
        AgentTooling.poolStrategy()
            .typePool(
                AgentTooling.locationStrategy()
                    .classFileLocator(ImplementsInterfaceMatcherTest.class.getClassLoader(), null),
                ImplementsInterfaceMatcherTest.class.getClassLoader());
  }

  @ParameterizedTest(name = "test matcher {0} -> {1}")
  @MethodSource("testMatcherProvider")
  void testMatcher(Class<?> matcherClass, Class<?> type, boolean expected) {
    ElementMatcher<NamedElement> matcher = named(matcherClass.getName());
    TypeDescription argument = typePool.describe(type.getName()).resolve();

    boolean result = implementsInterface(matcher).matches(argument);

    assertEquals(expected, result);
  }

  private static Stream<Arguments> testMatcherProvider() {
    return Stream.of(
        Arguments.of(A.class, A.class, true),
        Arguments.of(A.class, B.class, true),
        Arguments.of(B.class, A.class, false),
        Arguments.of(A.class, E.class, true),
        Arguments.of(A.class, F.class, true),
        Arguments.of(A.class, G.class, true),
        Arguments.of(F.class, A.class, false),
        Arguments.of(F.class, F.class, false),
        Arguments.of(F.class, G.class, false));
  }

  @Test
  void testExceptionGettingInterfaces() {
    TypeDescription type = mock(TypeDescription.class);
    TypeDescription.Generic typeGeneric = mock(TypeDescription.Generic.class);

    when(type.isInterface()).thenReturn(true);
    when(type.asGenericType()).thenReturn(typeGeneric);
    when(typeGeneric.asErasure()).thenThrow(new RuntimeException("asErasure exception"));
    when(type.getInterfaces()).thenThrow(new RuntimeException("getInterfaces exception"));
    when(type.getSuperClass()).thenThrow(new RuntimeException("getSuperClass exception"));

    boolean result = implementsInterface(named(Object.class.getName())).matches(type);

    // Should default to false when exception occurs
    assertFalse(result);
  }

  @Test
  void testTraversalExceptions() {
    TypeDescription type = mock(TypeDescription.class);
    TypeDescription.Generic typeGeneric = mock(TypeDescription.Generic.class);
    TypeList.Generic interfaces = mock(TypeList.Generic.class);
    @SuppressWarnings("unchecked")
    ThrowOnFirstElement iterator = new ThrowOnFirstElement();

    when(type.isInterface()).thenReturn(true);
    when(type.asGenericType()).thenReturn(typeGeneric);
    when(typeGeneric.asErasure()).thenThrow(new RuntimeException("asErasure exception"));
    when(type.getInterfaces()).thenReturn(interfaces);
    when(interfaces.iterator()).thenReturn(iterator);
    when(type.getSuperClass()).thenThrow(new RuntimeException("getSuperClass exception"));

    boolean result = implementsInterface(named(Object.class.getName())).matches(type);

    // Should default to false when exception occurs
    assertFalse(result);
  }
}